@page "/level-editor"
@using Match3.Core
@using Match3.Core.Config
@using Match3.Core.Logic
@using Match3.Core.Interfaces
@using Match3.Core.Structs
@using Match3.Core.Systems
@using Match3.Web.Services
@using Match3.Random
@using System.Text.Json
@using System.Threading
@using System.IO
@using System
@inject NavigationManager Navigation
@inject Match3GameService GameService
@inject ILoggerFactory LoggerFactory
@implements IDisposable
@rendermode InteractiveServer

<PageTitle>Level Editor</PageTitle>

<div class="d-flex flex-column vh-100 overflow-hidden" style="max-height: 100vh;">
    <!-- Header -->
    <header class="navbar navbar-dark bg-dark flex-shrink-0 px-3 py-2 shadow-sm justify-content-between">
        <div class="d-flex align-items-center gap-3">
            <span class="navbar-brand mb-0 h1 fs-5">Level Editor</span>
            
            <div class="btn-group btn-group-sm">
                <button class="btn @(CurrentMode == EditorMode.Level ? "btn-light" : "btn-outline-light")" 
                        @onclick="() => SwitchMode(EditorMode.Level)">
                    Level Design
                </button>
                <button class="btn @(CurrentMode == EditorMode.Scenario ? "btn-light" : "btn-outline-light")" 
                        @onclick="() => SwitchMode(EditorMode.Scenario)">
                    Scenario / Test
                </button>
            </div>
        </div>

        <div class="d-flex gap-2">
            @if (CurrentMode == EditorMode.Level)
            {
                <button class="btn btn-sm btn-success" @onclick="PlayLevel">
                    <i class="bi bi-play-fill"></i> Play Level
                </button>
            }
            <button class="btn btn-sm btn-outline-info" @onclick="ExportForAICritic">AI Critic</button>
        </div>
    </header>

    <div class="flex-grow-1 d-flex overflow-hidden">
        <!-- LEFT SIDEBAR: Configuration -->
        <aside class="bg-light border-end d-flex flex-column" style="width: 320px; min-width: 320px; overflow-y: auto;">
            <div class="p-3 border-bottom">
                <h6 class="text-uppercase text-muted small fw-bold mb-3">Grid Settings</h6>
                <div class="row g-2 align-items-end">
                    <div class="col-4">
                        <label class="form-label small mb-1">Width</label>
                        <input type="number" class="form-control form-control-sm" @bind="EditorWidth" min="3" max="12" />
                    </div>
                    <div class="col-4">
                        <label class="form-label small mb-1">Height</label>
                        <input type="number" class="form-control form-control-sm" @bind="EditorHeight" min="3" max="12" />
                    </div>
                    <div class="col-4">
                        <button class="btn btn-sm btn-secondary w-100" @onclick="ResizeGrid">Apply</button>
                    </div>
                </div>
                
                @if (CurrentMode == EditorMode.Level)
                {
                    <div class="mt-2">
                        <label class="form-label small mb-1">Move Limit</label>
                        <input type="number" class="form-control form-control-sm" @bind="CurrentLevel.MoveLimit" />
                    </div>
                }
            </div>

            <div class="flex-grow-1 p-3 overflow-auto">
                @if (CurrentMode == EditorMode.Level)
                {
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <h6 class="text-uppercase text-muted small fw-bold mb-0">Levels</h6>
                        <div class="btn-group btn-group-sm">
                            <button class="btn btn-outline-success py-0" @onclick="AddLevel" title="Add New">+</button>
                            <button class="btn btn-outline-primary py-0" @onclick="DuplicateSelectedLevel" disabled="@(SelectedLevelIndex < 0)" title="Duplicate">Copy</button>
                            <button class="btn btn-outline-danger py-0" @onclick="DeleteSelectedLevel" disabled="@(SelectedLevelIndex < 0)" title="Delete">Del</button>
                        </div>
                    </div>

                    <div class="list-group list-group-flush border rounded mb-3" style="max-height: 300px; overflow-y: auto;">
                        @for (int i = 0; i < LevelList.Count; i++)
                        {
                            var idx = i;
                            <button type="button" 
                                    class="list-group-item list-group-item-action py-2 px-2 d-flex justify-content-between align-items-center small @(SelectedLevelIndex == idx ? "active" : "")" 
                                    @onclick="() => SelectLevelIndex(idx)">
                                <span class="text-truncate" style="max-width: 150px;">@LevelList[idx].Name</span>
                                <span class="badge bg-secondary opacity-50">@LevelList[idx].Config.Width x @LevelList[idx].Config.Height</span>
                            </button>
                        }
                    </div>

                    <div class="input-group input-group-sm">
                        <input type="text" class="form-control" @bind="LevelNameEditing" placeholder="Level Name" disabled="@(SelectedLevelIndex < 0)" />
                        <button class="btn btn-outline-secondary" @onclick="ApplyLevelRename" disabled="@(SelectedLevelIndex < 0)">Rename</button>
                    </div>
                }
                else
                {
                    <!-- SCENARIO MODE CONTROLS -->
                    <h6 class="text-uppercase text-muted small fw-bold mb-3">Scenario Info</h6>
                    <div class="mb-2">
                        <label class="form-label small mb-1">Name</label>
                        <input type="text" class="form-control form-control-sm" @bind="CurrentScenario.Name" />
                    </div>
                    <div class="mb-2">
                        <label class="form-label small mb-1">Description</label>
                        <textarea class="form-control form-control-sm" rows="2" @bind="CurrentScenario.Description"></textarea>
                    </div>
                    <div class="mb-3">
                        <label class="form-label small mb-1">Random Seed</label>
                        <input type="number" class="form-control form-control-sm" @bind="CurrentScenario.Seed" />
                    </div>

                    <h6 class="text-uppercase text-muted small fw-bold mb-2">Recording</h6>
                    @if (!IsRecording)
                    {
                        <button class="btn btn-success btn-sm w-100 mb-2" @onclick="StartRecording">
                            <i class="bi bi-record-circle"></i> Start Recording
                        </button>
                    }
                    else
                    {
                        <button class="btn btn-danger btn-sm w-100 mb-2" @onclick="StopRecording">
                            <i class="bi bi-stop-circle"></i> Stop Recording
                        </button>
                        <div class="alert alert-info py-1 px-2 small mb-2 text-center">
                            Recording... Click grid to swap.
                        </div>
                    }

                    <div class="border rounded bg-white p-2 mb-3" style="height: 150px; overflow-y: auto;">
                        <div class="small text-muted mb-1">Moves: @CurrentScenario.Operations.Count</div>
                        <ul class="list-unstyled small mb-0 font-monospace">
                            @foreach (var move in CurrentScenario.Operations)
                            {
                                <li>(@move.FromX, @move.FromY) &rarr; (@move.ToX, @move.ToY)</li>
                            }
                        </ul>
                    </div>

                    <button class="btn btn-warning btn-sm w-100" @onclick="CaptureExpectedState" disabled="@(!IsRecording && SimulationController == null)">
                        Capture Result State
                    </button>
                    @if (CurrentScenario.ExpectedState.Grid.Length > 0)
                    {
                        <div class="text-success small text-center mt-1">
                            <i class="bi bi-check-circle"></i> State Captured
                        </div>
                    }
                }
            </div>
        </aside>

        <!-- CENTER: Canvas -->
        <main class="flex-grow-1 bg-secondary bg-opacity-10 d-flex flex-column position-relative overflow-hidden">
            <!-- Toolbar Overlay -->
            <div class="position-absolute top-0 start-50 translate-middle-x mt-3 bg-white shadow-sm rounded-pill px-3 py-1 d-flex gap-3 align-items-center z-index-10 border" style="z-index: 100;">
                <div class="small fw-bold text-muted">@(IsRecording ? "üî¥ RECORDING" : "‚úèÔ∏è EDITING")</div>
                <div class="vr"></div>
                <div class="small text-muted">@ActiveLevelConfig.Width x @ActiveLevelConfig.Height</div>
            </div>

            <!-- Grid Container -->
            <div class="flex-grow-1 d-flex align-items-center justify-content-center overflow-auto p-5">
                @{
                    var currentConfig = ActiveLevelConfig;
                    var width = currentConfig.Width;
                    var height = currentConfig.Height;
                    var scale = 1.0; // Could add zoom later
                    var tileSize = 60;
                }
                <div class="position-relative shadow-lg bg-white" 
                     style="width: @(width * tileSize)px; height: @(height * tileSize)px; border: 10px solid #fff; border-radius: 4px;"
                     @onmouseleave="StopDrawing"
                     @onmouseup="StopDrawing">
                    
                    @for (int i = 0; i < currentConfig.Grid.Length; i++)
                    {
                        var index = i;
                        var x = i % width;
                        var y = i / width;
                        var displayType = GetTileType(index);
                        var displayBomb = GetBomb(index);
                        var isSelected = IsRecording && SimulationController?.SelectedPosition == new Position(x, y);

                        <div class="position-absolute border border-light" 
                             style="left: @(x * tileSize)px; top: @(y * tileSize)px; width: @(tileSize)px; height: @(tileSize)px; background-color: @GetColor(displayType); cursor: pointer; transition: transform 0.1s;"
                             @onmousedown="() => HandleGridClick(index)"
                             @onmouseenter="() => PaintTile(index)"
                             @ondragstart:preventDefault="true">
                             
                             @if (isSelected)
                             {
                                 <div class="position-absolute top-0 start-0 w-100 h-100 border border-3 border-white shadow-sm" style="z-index: 5;"></div>
                             }

                            <div class="w-100 h-100 d-flex align-items-center justify-content-center" style="pointer-events: none;">
                                @if (displayType != TileType.None)
                                {
                                    <!-- Simple shine effect or icon could go here -->
                                }
                            </div>
                            
                            @if (displayBomb != BombType.None)
                            {
                                <div class="position-absolute top-50 start-50 translate-middle fs-4" style="pointer-events:none; text-shadow: 0 0 5px rgba(255,255,255,0.8);">
                                    @GetBombIcon(displayBomb)
                                </div>
                            }
                        </div>
                    }
                </div>
            </div>
        </main>

        <!-- RIGHT SIDEBAR: Tools -->
        <aside class="bg-light border-start d-flex flex-column" style="width: 280px; min-width: 280px; overflow-y: auto;">
            <div class="p-3 border-bottom">
                <h6 class="text-uppercase text-muted small fw-bold mb-3">Palette</h6>
                <div class="d-grid gap-2" style="grid-template-columns: repeat(4, 1fr);">
                    @foreach (var type in Enum.GetValues<TileType>())
                    {
                        <button class="btn p-0 border position-relative @(SelectedType == type ? "border-primary border-3" : "")" 
                                style="height: 48px; background-color: @GetColor(type); box-shadow: @(SelectedType == type ? "inset 0 0 0 1px rgba(255,255,255,0.5)" : "none")"
                                @onclick="() => SelectedType = type"
                                title="@type"
                                disabled="@IsRecording">
                            @if (SelectedType == type) { <span class="position-absolute top-50 start-50 translate-middle text-white small">‚úì</span> }
                        </button>
                    }
                </div>
            </div>

            <div class="p-3 border-bottom">
                <h6 class="text-uppercase text-muted small fw-bold mb-3">Items / Bombs</h6>
                <div class="d-grid gap-2" style="grid-template-columns: repeat(3, 1fr);">
                    @foreach (var bomb in (BombType[])Enum.GetValues(typeof(BombType)))
                    {
                        <button class="btn btn-outline-secondary p-1 d-flex flex-column align-items-center justify-content-center @(SelectedBomb == bomb ? "active" : "")" 
                                style="height: 60px;"
                                @onclick="() => SelectedBomb = bomb"
                                title="@bomb"
                                disabled="@IsRecording">
                            <span class="fs-4">@GetBombIcon(bomb)</span>
                            <span style="font-size: 10px;">@bomb</span>
                        </button>
                    }
                </div>
            </div>

            <div class="flex-grow-1 p-3">
                <h6 class="text-uppercase text-muted small fw-bold mb-3">Data IO</h6>
                
                @if (CurrentMode == EditorMode.Scenario)
                {
                     <button class="btn btn-primary btn-sm w-100 mb-2" @onclick="ExportTestJsonToDirectory">Save Test JSON</button>
                     <button class="btn btn-outline-secondary btn-sm w-100 mb-2" @onclick="ExportCSharp">Export C# Code</button>
                }
                
                <div class="btn-group w-100 mb-2">
                    <button class="btn btn-success btn-sm" @onclick="ExportJson">Export</button>
                    <button class="btn btn-warning btn-sm" @onclick="ImportJson">Import</button>
                </div>
                
                <textarea class="form-control form-control-sm font-monospace small" rows="8" @bind="JsonOutput" style="white-space: pre; overflow-x: auto;"></textarea>
            </div>
        </aside>
    </div>
</div>

@code {
    private enum EditorMode { Level, Scenario }
    private EditorMode CurrentMode { get; set; } = EditorMode.Level;

    // Level Mode Data
    private LevelConfig CurrentLevel { get; set; } = new LevelConfig();
    private sealed class LevelItem
    {
        public string Name { get; set; } = "Level";
        public LevelConfig Config { get; set; } = new LevelConfig();
        public BombType[] Bombs { get; set; } = new BombType[8 * 8];
    }
    private List<LevelItem> LevelList { get; set; } = new();
    private int SelectedLevelIndex { get; set; } = -1;
    private string LevelNameEditing { get; set; } = "";

    // Scenario Mode Data
    private ScenarioConfig CurrentScenario { get; set; } = new ScenarioConfig();
    private bool IsRecording { get; set; }
    private Match3Controller? SimulationController;
    private CancellationTokenSource? _simLoopCts;

    // Shared UI State
    private int EditorWidth { get; set; } = 8;
    private int EditorHeight { get; set; } = 8;
    private TileType SelectedType { get; set; } = TileType.Red;
    private BombType SelectedBomb { get; set; } = BombType.None;
    private string JsonOutput { get; set; } = "";
    private bool IsDrawing { get; set; } = false;

    private LevelConfig ActiveLevelConfig => CurrentMode == EditorMode.Level ? CurrentLevel : CurrentScenario.InitialState;
    private BombType[] LevelBombs { get; set; } = new BombType[8 * 8];
    private BombType[] ScenarioBombs { get; set; } = new BombType[8 * 8];
    private BombType[] ActiveBombs => CurrentMode == EditorMode.Level ? LevelBombs : ScenarioBombs;

    protected override void OnInitialized()
    {
        EnsureDefaultLevel();
    }

    private void SwitchMode(EditorMode mode)
    {
        CurrentMode = mode;
        // Sync dimensions when switching
        if (mode == EditorMode.Scenario)
        {
            EditorWidth = CurrentScenario.InitialState.Width;
            EditorHeight = CurrentScenario.InitialState.Height;
        }
        else
        {
            EnsureDefaultLevel();
            EditorWidth = CurrentLevel.Width;
            EditorHeight = CurrentLevel.Height;
            LevelNameEditing = SelectedLevelIndex >= 0 ? LevelList[SelectedLevelIndex].Name : "";
        }
        IsRecording = false;
        StopLoop();
    }

    private void ResizeGrid()
    {
        if (CurrentMode == EditorMode.Level)
        {
            CurrentLevel = new LevelConfig(EditorWidth, EditorHeight) { MoveLimit = CurrentLevel.MoveLimit };
            LevelBombs = new BombType[EditorWidth * EditorHeight];
            if (SelectedLevelIndex >= 0 && SelectedLevelIndex < LevelList.Count)
            {
                LevelList[SelectedLevelIndex].Config = CurrentLevel;
                LevelList[SelectedLevelIndex].Bombs = LevelBombs;
            }
        }
        else
        {
            // For Scenario, we resize the InitialState
            // Note: This might invalidate operations, but that's user's responsibility
            var newLevel = new LevelConfig(EditorWidth, EditorHeight);
            CurrentScenario.InitialState = newLevel;
            CurrentScenario.Operations.Clear();
            CurrentScenario.ExpectedState = new LevelConfig(); // Clear expected
            ScenarioBombs = new BombType[EditorWidth * EditorHeight];
        }
    }

    private void EnsureDefaultLevel()
    {
        if (LevelList.Count == 0)
        {
            var item = new LevelItem
            {
                Name = "Level 1",
                Config = new LevelConfig(EditorWidth, EditorHeight),
                Bombs = new BombType[EditorWidth * EditorHeight]
            };
            LevelList.Add(item);
            SelectedLevelIndex = 0;
            CurrentLevel = item.Config;
            LevelBombs = item.Bombs;
            LevelNameEditing = item.Name;
        }
        else if (SelectedLevelIndex < 0 || SelectedLevelIndex >= LevelList.Count)
        {
            SelectedLevelIndex = 0;
            var item = LevelList[0];
            CurrentLevel = item.Config;
            LevelBombs = item.Bombs;
            LevelNameEditing = item.Name;
        }
    }

    private void AddLevel()
    {
        var idx = LevelList.Count + 1;
        var item = new LevelItem
        {
            Name = $"Level {idx}",
            Config = new LevelConfig(EditorWidth, EditorHeight),
            Bombs = new BombType[EditorWidth * EditorHeight]
        };
        LevelList.Add(item);
        SelectLevelIndex(LevelList.Count - 1);
    }

    private void SelectLevelIndex(int index)
    {
        if (index < 0 || index >= LevelList.Count) return;
        SelectedLevelIndex = index;
        var item = LevelList[index];
        CurrentLevel = item.Config;
        LevelBombs = item.Bombs;
        EditorWidth = item.Config.Width;
        EditorHeight = item.Config.Height;
        LevelNameEditing = item.Name;
    }

    private void DuplicateSelectedLevel()
    {
        if (SelectedLevelIndex < 0 || SelectedLevelIndex >= LevelList.Count) return;
        var src = LevelList[SelectedLevelIndex];
        var copy = new LevelItem
        {
            Name = src.Name + " Copy",
            Config = new LevelConfig(src.Config.Width, src.Config.Height) { MoveLimit = src.Config.MoveLimit },
            Bombs = new BombType[src.Config.Width * src.Config.Height]
        };
        Array.Copy(src.Config.Grid, copy.Config.Grid, src.Config.Grid.Length);
        Array.Copy(src.Bombs, copy.Bombs, src.Bombs.Length);
        LevelList.Add(copy);
        SelectLevelIndex(LevelList.Count - 1);
    }

    private void DeleteSelectedLevel()
    {
        if (SelectedLevelIndex < 0 || SelectedLevelIndex >= LevelList.Count) return;
        LevelList.RemoveAt(SelectedLevelIndex);
        if (LevelList.Count == 0)
        {
            SelectedLevelIndex = -1;
            CurrentLevel = new LevelConfig(EditorWidth, EditorHeight);
            LevelBombs = new BombType[EditorWidth * EditorHeight];
            LevelNameEditing = "";
        }
        else
        {
            SelectLevelIndex(Math.Min(SelectedLevelIndex, LevelList.Count - 1));
        }
    }

    private void ApplyLevelRename()
    {
        if (SelectedLevelIndex < 0 || SelectedLevelIndex >= LevelList.Count) return;
        LevelList[SelectedLevelIndex].Name = LevelNameEditing ?? "";
    }

    private void HandleGridClick(int index)
    {
        if (IsRecording)
        {
            if (SimulationController != null)
            {
                var w = ActiveLevelConfig.Width;
                var x = index % w;
                var y = index / w;
                SimulationController.OnTap(new Position(x, y));
            }
        }
        else
        {
            // Drawing Mode
            StartDrawing(index);
        }
    }

    private void StartDrawing(int index)
    {
        if (IsRecording) return;
        IsDrawing = true;
        PaintTile(index);
    }

    private void PaintTile(int index)
    {
        if (IsDrawing && !IsRecording && index >= 0 && index < ActiveLevelConfig.Grid.Length)
        {
            if (SelectedBomb == BombType.Color)
            {
                ActiveLevelConfig.Grid[index] = TileType.Rainbow;
            }
            else
            {
                ActiveLevelConfig.Grid[index] = SelectedType;
            }
            ActiveBombs[index] = SelectedBomb;
        }
    }

    private void StopDrawing()
    {
        IsDrawing = false;
    }

    private TileType GetTileType(int index)
    {
        if (IsRecording && SimulationController != null)
        {
            var w = ActiveLevelConfig.Width;
            var x = index % w;
            var y = index / w;
            // Access state safely
            try 
            {
                return SimulationController.State.GetType(x, y);
            }
            catch { return TileType.None; }
        }
        return ActiveLevelConfig.Grid[index];
    }
    private BombType GetBomb(int index)
    {
        if (IsRecording && SimulationController != null)
        {
            var w = ActiveLevelConfig.Width;
            var x = index % w;
            var y = index / w;
            try
            {
                return SimulationController.State.GetTile(x, y).Bomb;
            }
            catch { return BombType.None; }
        }
        return index >= 0 && index < ActiveBombs.Length ? ActiveBombs[index] : BombType.None;
    }

    // --- Recording Logic ---

    private void StartRecording()
    {
        IsRecording = true;
        CurrentScenario.Operations.Clear();
        
        // Initialize Controller with Current InitialState
        // Use the seed from scenario for deterministic behavior
        var seed = CurrentScenario.Seed;
        var rng = new SeedManager(seed).GetRandom(RandomDomain.Main); 
        
        var view = new EditorGameView(this);
        var tileGenerator = new StandardTileGenerator(new SeedManager(seed).GetRandom(RandomDomain.Refill));
        var gravity = new StandardGravitySystem(tileGenerator);
        var finder = new ClassicMatchFinder();
        var scoreSystem = new StandardScoreSystem();
        var processor = new StandardMatchProcessor(scoreSystem);
        var powerup = new PowerUpHandler(scoreSystem);
        var inputSystem = new StandardInputSystem();
        var logger = new ConsoleGameLogger(); // Or a dummy logger
        
        var config = new Match3Config(ActiveLevelConfig.Width, ActiveLevelConfig.Height, 6);
        
        SimulationController = new Match3Controller(
            config, rng, view, finder, processor, gravity, powerup, tileGenerator, logger, scoreSystem, inputSystem, ActiveLevelConfig
        );

        // Apply initial bombs to simulation state
        var bombs = ActiveBombs;
        for (int i = 0; i < bombs.Length && i < ActiveLevelConfig.Grid.Length; i++)
        {
            if (bombs[i] != BombType.None)
            {
                var w = ActiveLevelConfig.Width;
                var x = i % w;
                var y = i / w;
                var t = SimulationController.State.GetTile(x, y);
                if (bombs[i] == BombType.Color)
                {
                    SimulationController.SetTileWithBomb(x, y, TileType.Rainbow, bombs[i]);
                }
                else
                {
                    SimulationController.SetTileWithBomb(x, y, t.Type, bombs[i]);
                }
            }
        }

        StartLoop();
    }

    private void StopRecording()
    {
        IsRecording = false;
        StopLoop();
        // Keep SimulationController alive so user can see final state and Capture it
    }

    private void CaptureExpectedState()
    {
        if (SimulationController == null) return;
        
        var state = SimulationController.State;
        var expected = new LevelConfig(state.Width, state.Height);
        
        for (int i = 0; i < state.Grid.Length; i++)
        {
            expected.Grid[i] = state.Grid[i].Type;
        }
        
        CurrentScenario.ExpectedState = expected;
    }

    public void RecordMove(Position a, Position b)
    {
        CurrentScenario.Operations.Add(new MoveOperation(a.X, a.Y, b.X, b.Y));
        InvokeAsync(StateHasChanged);
    }
    
    public void RequestUpdate()
    {
        InvokeAsync(StateHasChanged);
    }

    private void StartLoop()
    {
        StopLoop();
        _simLoopCts = new CancellationTokenSource();
        _ = SimulationLoop(_simLoopCts.Token);
    }

    private void StopLoop()
    {
        _simLoopCts?.Cancel();
        _simLoopCts = null;
    }

    private async Task SimulationLoop(CancellationToken token)
    {
        while (!token.IsCancellationRequested)
        {
            if (SimulationController != null)
            {
                SimulationController.Update(0.016f);
                await InvokeAsync(StateHasChanged);
            }
            await Task.Delay(16, token);
        }
    }

    private class EditorGameView : IGameView
    {
        private readonly LevelEditor _editor;
        public EditorGameView(LevelEditor editor) => _editor = editor;
        
        public void RenderBoard(TileType[,] board) { _editor.RequestUpdate(); }
        public void ShowSwap(Position a, Position b, bool success) 
        {
            if (success) _editor.RecordMove(a, b);
            _editor.RequestUpdate();
        }
        public void ShowMatches(IReadOnlyCollection<Position> matched) { _editor.RequestUpdate(); }
        public void ShowGravity(IEnumerable<TileMove> moves) { _editor.RequestUpdate(); }
        public void ShowRefill(IEnumerable<TileMove> moves) { _editor.RequestUpdate(); }
    }
    
    public void Dispose()
    {
        StopLoop();
    }

    // --- JSON Logic ---

    private sealed class ExportScenario
    {
        public string Name { get; set; } = "";
        public int Width { get; set; }
        public int Height { get; set; }
        public string[] Layout { get; set; } = System.Array.Empty<string>();
        public List<ExportMove> Moves { get; set; } = new();
        public List<ExportExpectation> Expectations { get; set; } = new();
    }

    private sealed class ExportMove
    {
        public string From { get; set; } = "";
        public string To { get; set; } = "";
    }

    private sealed class ExportExpectation
    {
        public int X { get; set; }
        public int Y { get; set; }
        public string? Type { get; set; }
        public string? Bomb { get; set; }
    }

    private string ToCode(TileType t)
    {
        return t switch
        {
            TileType.None => "_",
            TileType.Red => "R",
            TileType.Green => "G",
            TileType.Blue => "B",
            TileType.Yellow => "Y",
            TileType.Purple => "P",
            TileType.Orange => "O",
            TileType.Rainbow => "Rainbow",
            _ => "_"
        };
    }

    private void ExportTestJsonToDirectory()
    {
        if (CurrentMode != EditorMode.Scenario) return;

        var width = CurrentScenario.InitialState.Width;
        var height = CurrentScenario.InitialState.Height;
        var grid = CurrentScenario.InitialState.Grid;

        var layout = new string[height];
        for (int y = 0; y < height; y++)
        {
            var rowCodes = new string[width];
            for (int x = 0; x < width; x++)
            {
                rowCodes[x] = ToCode(grid[y * width + x]);
            }
            layout[y] = string.Join(", ", rowCodes);
        }

        var moves = new List<ExportMove>();
        foreach (var op in CurrentScenario.Operations)
        {
            moves.Add(new ExportMove
            {
                From = $"{op.FromX},{op.FromY}",
                To = $"{op.ToX},{op.ToY}"
            });
        }

        var expectations = new List<ExportExpectation>();
        if (CurrentScenario.ExpectedState != null && CurrentScenario.ExpectedState.Grid != null && CurrentScenario.ExpectedState.Grid.Length > 0)
        {
            var exW = CurrentScenario.ExpectedState.Width;
            var exH = CurrentScenario.ExpectedState.Height;
            var exGrid = CurrentScenario.ExpectedState.Grid;
            for (int y = 0; y < exH; y++)
            {
                for (int x = 0; x < exW; x++)
                {
                    var expectedTypeCode = ToCode(exGrid[y * exW + x]);
                    var initialTypeCode = ToCode(grid[y * width + x]);
                    var bombCode = (SimulationController != null) 
                        ? (SimulationController.State.GetTile(x, y).Bomb == BombType.None ? null : SimulationController.State.GetTile(x, y).Bomb.ToString())
                        : null;
                    if ((expectedTypeCode != initialTypeCode && expectedTypeCode != "_") || bombCode != null)
                    {
                        expectations.Add(new ExportExpectation
                        {
                            X = x,
                            Y = y,
                            Type = expectedTypeCode == "_" ? null : expectedTypeCode,
                            Bomb = bombCode
                        });
                    }
                }
            }
        }

        var export = new ExportScenario
        {
            Name = CurrentScenario.Name ?? "",
            Width = width,
            Height = height,
            Layout = layout,
            Moves = moves,
            Expectations = expectations
        };

        var options = new JsonSerializerOptions { WriteIndented = true };
        var json = JsonSerializer.Serialize(export, options);
        JsonOutput = json;

        var targetDir = @"d:\GitWorkSpace\LiuJun\ThreeMatchTrea\src\Match3.Tests\Scenarios\Data";
        Directory.CreateDirectory(targetDir);

        string safeName = string.IsNullOrWhiteSpace(CurrentScenario.Name) ? "scenario" : CurrentScenario.Name;
        foreach (var c in Path.GetInvalidFileNameChars())
        {
            safeName = safeName.Replace(c, '_');
        }
        var fileName = $"{safeName}_{DateTime.Now:yyyyMMdd_HHmmss}.json";
        var path = Path.Combine(targetDir, fileName);
        File.WriteAllText(path, json);
    }

    private void ExportForAICritic()
    {
        var sb = new System.Text.StringBuilder();
        sb.AppendLine("Role: You are a senior level designer for a Match-3 game.");
        sb.AppendLine("Task: Evaluate the following level design based on Visual Aesthetics, Strategic Depth, and Potential Issues.");
        sb.AppendLine();
        sb.AppendLine("=== Level Data ===");
        sb.AppendLine($"Size: {ActiveLevelConfig.Width}x{ActiveLevelConfig.Height}");
        if (CurrentMode == EditorMode.Level)
        {
            sb.AppendLine($"Move Limit: {CurrentLevel.MoveLimit}");
        }
        sb.AppendLine();
        sb.AppendLine("=== Grid Layout (ASCII) ===");
        sb.AppendLine("Legend: R=Red, G=Green, B=Blue, Y=Yellow, P=Purple, O=Orange, X=Rainbow, #=None/Empty");
        sb.AppendLine();

        var width = ActiveLevelConfig.Width;
        var height = ActiveLevelConfig.Height;
        var grid = ActiveLevelConfig.Grid;

        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                var idx = y * width + x;
                var type = grid[idx];
                char c = type switch
                {
                    TileType.Red => 'R',
                    TileType.Green => 'G',
                    TileType.Blue => 'B',
                    TileType.Yellow => 'Y',
                    TileType.Purple => 'P',
                    TileType.Orange => 'O',
                    TileType.Rainbow => 'X',
                    TileType.None => '#',
                    _ => '?'
                };
                sb.Append(c + " ");
            }
            sb.AppendLine();
        }
        
        sb.AppendLine();
        sb.AppendLine("=== Instructions ===");
        sb.AppendLine("Please provide a score (0-10) and a qualitative critique.");
        
        JsonOutput = sb.ToString();
    }

    private void ExportJson()
    {
        var options = new JsonSerializerOptions { WriteIndented = true };
        if (CurrentMode == EditorMode.Level)
        {
            JsonOutput = JsonSerializer.Serialize(CurrentLevel, options);
        }
        else
        {
            JsonOutput = JsonSerializer.Serialize(CurrentScenario, options);
        }
    }

    private void ExportCSharp()
    {
        if (CurrentMode != EditorMode.Scenario) return;
        
        var sb = new System.Text.StringBuilder();
        sb.AppendLine("[Fact]");
        sb.AppendLine($"public void Scenario_{CurrentScenario.Name.Replace(" ", "_")}()");
        sb.AppendLine("{");
        sb.AppendLine("    // Generated by LevelEditor");
        sb.AppendLine("    var scenario = new ScenarioConfig");
        sb.AppendLine("    {");
        sb.AppendLine($"        Name = \"{CurrentScenario.Name}\",");
        sb.AppendLine($"        Description = \"{CurrentScenario.Description}\",");
        sb.AppendLine($"        Seed = {CurrentScenario.Seed},");
        
        // Initial State
        sb.AppendLine("        InitialState = new LevelConfig");
        sb.AppendLine("        {");
        sb.AppendLine($"            Width = {CurrentScenario.InitialState.Width},");
        sb.AppendLine($"            Height = {CurrentScenario.InitialState.Height},");
        sb.AppendLine("            Grid = new TileType[]");
        sb.AppendLine("            {");
        
        var grid = CurrentScenario.InitialState.Grid;
        var w = CurrentScenario.InitialState.Width;
        for(int y=0; y<CurrentScenario.InitialState.Height; y++)
        {
            sb.Append("                ");
            for(int x=0; x<w; x++)
            {
                sb.Append($"TileType.{grid[y*w + x]}, ");
            }
            sb.AppendLine();
        }
        sb.AppendLine("            }");
        sb.AppendLine("        },"); // End InitialState

        // Operations
        sb.AppendLine("        Operations = new List<MoveOperation>");
        sb.AppendLine("        {");
        foreach(var op in CurrentScenario.Operations)
        {
            sb.AppendLine($"            new MoveOperation({op.FromX}, {op.FromY}, {op.ToX}, {op.ToY}),");
        }
        sb.AppendLine("        },");

        // Expected State
        if (CurrentScenario.ExpectedState != null && CurrentScenario.ExpectedState.Grid != null && CurrentScenario.ExpectedState.Grid.Length > 0)
        {
            sb.AppendLine("        ExpectedState = new LevelConfig");
            sb.AppendLine("        {");
            sb.AppendLine($"            Width = {CurrentScenario.ExpectedState.Width},");
            sb.AppendLine($"            Height = {CurrentScenario.ExpectedState.Height},");
            sb.AppendLine("            Grid = new TileType[]");
            sb.AppendLine("            {");
            
            var exGrid = CurrentScenario.ExpectedState.Grid;
            var exW = CurrentScenario.ExpectedState.Width;
             for(int y=0; y<CurrentScenario.ExpectedState.Height; y++)
            {
                sb.Append("                ");
                for(int x=0; x<exW; x++)
                {
                    sb.Append($"TileType.{exGrid[y*exW + x]}, ");
                }
                sb.AppendLine();
            }
            sb.AppendLine("            }");
            sb.AppendLine("        }");
        }
        else
        {
             sb.AppendLine("        ExpectedState = new LevelConfig()");
        }

        sb.AppendLine("    };");
        sb.AppendLine();
        sb.AppendLine("    // RunScenario(scenario); // Assuming you have a helper method");
        sb.AppendLine("}");

        JsonOutput = sb.ToString();
    }

    private void ImportJson()
    {
        try
        {
            if (string.IsNullOrWhiteSpace(JsonOutput)) return;
            
            // Try to guess format or just try deserializing
            // Simple heuristic: check if it has "Operations" property
            if (JsonOutput.Contains("Operations"))
            {
                var loaded = JsonSerializer.Deserialize<ScenarioConfig>(JsonOutput);
                if (loaded != null)
                {
                    CurrentScenario = loaded;
                    CurrentMode = EditorMode.Scenario;
                    EditorWidth = loaded.InitialState.Width;
                    EditorHeight = loaded.InitialState.Height;
                }
            }
            else
            {
                var loaded = JsonSerializer.Deserialize<LevelConfig>(JsonOutput);
                if (loaded != null)
                {
                    CurrentLevel = loaded;
                    CurrentMode = EditorMode.Level;
                    EditorWidth = loaded.Width;
                    EditorHeight = loaded.Height;
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error importing JSON: {ex.Message}");
        }
    }

    private void PlayLevel()
    {
        GameService.StartNewGame(CurrentLevel);
        Navigation.NavigateTo("/");
    }

    private string GetColor(TileType type) => type switch
    {
        TileType.Red => "#ff4444",
        TileType.Green => "#44ff44",
        TileType.Blue => "#4444ff",
        TileType.Yellow => "#ffff44",
        TileType.Purple => "#ff44ff",
        TileType.Orange => "#ffaa44",
        TileType.Rainbow => "linear-gradient(45deg, red, orange, yellow, green, blue, indigo, violet)",
        TileType.None => "#eee4da",
        _ => "#cccccc"
    };
    private string GetBombIcon(BombType bomb) => bomb switch
    {
        BombType.None => "",
        BombType.Horizontal => "‚ÜîÔ∏è",
        BombType.Vertical => "‚ÜïÔ∏è",
        BombType.Ufo => "üõ∏",
        BombType.Square3x3 => "üí£",
        BombType.Color => "üåà",
        _ => ""
    };
}
