@page "/"
@using Match3.Core
@using Match3.Core.Structs
@using System.Numerics
@rendermode InteractiveServer
@implements IDisposable

<PageTitle>Match3 Game</PageTitle>

<div class="game-container" @onpointerup="HandlePointerUp">
    <div class="header">
        <h1>Match3 Blast</h1>
        <div class="stats">
            <div class="stat-box">
                <span class="stat-label">Matches</span>
                <span class="stat-value" data-testid="matches-count">@LastMatchesCount</span>
            </div>
            <div class="stat-box">
                <span class="stat-label">Status</span>
                <span class="stat-value status-text" data-testid="status-message">@StatusMessage</span>
            </div>
        </div>
    </div>

    @if (Controller != null)
    {
        <div class="board-wrapper">
            <div class="board-container" style="width: @(Width * CellSize)px; height: @(Height * CellSize)px;">
                <!-- Background Grid -->
                @for (int y = 0; y < Height; y++)
                {
                    @for (int x = 0; x < Width; x++)
                    {
                        var px = x;
                        var py = y;
                        <div class="cell-bg" 
                             style="left: @(x * CellSize)px; top: @(y * CellSize)px;"
                             @onpointerdown="e => HandlePointerDown(e, px, py)">
                        </div>
                    }
                }

                <!-- Active Tiles -->
                @foreach (var tile in Controller.State.Grid)
                {
                    if (tile.Type != TileType.None)
                    {
                        var isSelected = SelectedX != -1 && 
                                       Math.Abs(tile.Position.X - SelectedX) < 0.1f && 
                                       Math.Abs(tile.Position.Y - SelectedY) < 0.1f;
                        
                        <div class="tile @(isSelected ? "selected" : "")" 
                             style="transform: translate(@(tile.Position.X * CellSize)px, @(tile.Position.Y * CellSize)px);"
                             @onpointerdown="e => HandlePointerDown(e, (int)Math.Round(tile.Position.X), (int)Math.Round(tile.Position.Y))">
                            <span class="tile-content">@GetTileContent(tile)</span>
                        </div>
                    }
                }
            </div>
        </div>
        
        <div class="controls">
            <button @onclick="ResetGame" class="btn-reset">New Game</button>
        </div>
    }
    else
    {
        <div class="loading">Loading Board...</div>
    }
</div>

<style>
    :root {
        --tile-size: 60px;
        --gap: 6px;
    }

    .game-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background-color: #f0f2f5;
        padding: 2rem;
        border-radius: 1rem;
        max-width: 800px;
        margin: 0 auto;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    .header {
        text-align: center;
        margin-bottom: 2rem;
        width: 100%;
    }

    h1 {
        color: #1a1a1a;
        margin-bottom: 1rem;
        font-weight: 800;
        text-transform: uppercase;
        letter-spacing: -0.025em;
    }

    .stats {
        display: flex;
        justify-content: center;
        gap: 2rem;
    }

    .stat-box {
        background: white;
        padding: 0.75rem 1.5rem;
        border-radius: 0.5rem;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        display: flex;
        flex-direction: column;
        align-items: center;
        min-width: 120px;
    }

    .stat-label {
        font-size: 0.75rem;
        color: #6b7280;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        font-weight: 600;
    }

    .stat-value {
        font-size: 1.25rem;
        font-weight: 700;
        color: #111827;
    }

    .status-text {
        font-size: 1rem;
        color: #3b82f6;
    }

    .board-wrapper {
        background: #bbada0;
        padding: 10px;
        border-radius: 6px;
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    }

    .board-container {
        position: relative;
        background-color: #bbada0;
    }

    .cell-bg {
        position: absolute;
        width: 60px;
        height: 60px;
        background-color: rgba(238, 228, 218, 0.35);
        border-radius: 4px;
        margin: 3px; /* Half gap */
        touch-action: none;
    }

    .tile {
        position: absolute;
        width: 60px;
        height: 60px;
        background-color: #eee4da; /* Default tile color */
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        user-select: none;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        margin: 3px; /* Half gap */
        /* IMPORTANT: No transition here, fully controlled by Model */
        z-index: 10;
        touch-action: none; /* Prevent browser scrolling/zooming/native drag */
    }

    .tile.selected {
        box-shadow: 0 0 0 3px #3b82f6, 0 4px 6px rgba(0,0,0,0.2);
        z-index: 20;
        filter: brightness(1.1);
    }

    .tile-content {
        font-size: 2rem;
        line-height: 1;
        filter: drop-shadow(0 2px 2px rgba(0,0,0,0.2));
    }

    .controls {
        margin-top: 2rem;
        text-align: center;
    }

    .btn-reset {
        background-color: #8f7a66;
        color: white;
        border: none;
        padding: 0.75rem 2rem;
        font-size: 1rem;
        font-weight: 600;
        border-radius: 0.375rem;
        cursor: pointer;
        transition: background-color 0.2s;
    }

    .btn-reset:hover {
        background-color: #9f8a76;
    }
</style>

@code {
    private Match3Controller? Controller;
    private int Width = 8;
    private int Height = 8;
    private const int CellSize = 66; // 60px + 6px gap
    
    private int SelectedX = -1;
    private int SelectedY = -1;
    private int LastMatchesCount = 0;
    private string StatusMessage = "Ready";
    
    private bool _disposed = false;
    private const int TargetFps = 60;
    private const int FrameMs = 1000 / TargetFps;

    // Drag & Drop State
    private double? _dragStartX;
    private double? _dragStartY;
    private int _dragSourceX = -1;
    private int _dragSourceY = -1;
    private const double DragThreshold = 20.0; // pixels

    protected override void OnInitialized()
    {
        StartNewGame();
    }

    public void Dispose()
    {
        _disposed = true;
    }

    private void StartNewGame()
    {
        var rng = new DefaultRandom(Environment.TickCount);
        var view = new BlazorGameView(this);
        Controller = new Match3Controller(Width, Height, 6, rng, view);
        StatusMessage = "Ready";
        LastMatchesCount = 0;
        SelectedX = -1;
        SelectedY = -1;
        
        // Start Game Loop
        _ = GameLoopAsync();
    }

    private void ResetGame()
    {
        StartNewGame();
    }
    
    private async Task GameLoopAsync()
    {
        while (!_disposed)
        {
            if (Controller != null)
            {
                // Update Logic
                Controller.Update(FrameMs / 1000.0f);
                
                // Update UI
                await InvokeAsync(StateHasChanged);
            }
            
            await Task.Delay(FrameMs);
        }
    }

    private void HandlePointerDown(PointerEventArgs e, int x, int y)
    {
        if (Controller == null || !Controller.IsIdle) return;
        
        _dragStartX = e.ClientX;
        _dragStartY = e.ClientY;
        _dragSourceX = x;
        _dragSourceY = y;
    }

    private void HandlePointerUp(PointerEventArgs e)
    {
        if (_dragStartX == null || _dragStartY == null || _dragSourceX == -1) return;

        var deltaX = e.ClientX - _dragStartX.Value;
        var deltaY = e.ClientY - _dragStartY.Value;
        var distance = Math.Sqrt(deltaX * deltaX + deltaY * deltaY);

        if (distance < DragThreshold)
        {
            // Treat as Click
            OnTileClick(_dragSourceX, _dragSourceY);
        }
        else
        {
            // Treat as Swipe
            HandleSwipe(deltaX, deltaY);
        }

        // Reset
        _dragStartX = null;
        _dragStartY = null;
        _dragSourceX = -1;
        _dragSourceY = -1;
    }

    private void HandleSwipe(double dx, double dy)
    {
        if (Controller == null || !Controller.IsIdle) return;

        // Determine main direction
        int targetX = _dragSourceX;
        int targetY = _dragSourceY;

        if (Math.Abs(dx) > Math.Abs(dy))
        {
            // Horizontal
            if (dx > 0) targetX++; else targetX--;
        }
        else
        {
            // Vertical
            if (dy > 0) targetY++; else targetY--;
        }

        // Boundary check
        if (targetX >= 0 && targetX < Width && targetY >= 0 && targetY < Height)
        {
            var p1 = new Position(_dragSourceX, _dragSourceY);
            var p2 = new Position(targetX, targetY);
            
            // "Drag" overrides "Selection", so clear selection
            SelectedX = -1;
            SelectedY = -1;
            
            bool allowed = Controller.TrySwap(p1, p2);
            if (!allowed)
            {
                StatusMessage = "Invalid Move";
            }
            else
            {
                StatusMessage = "Swapping...";
            }
        }
    }

    private void OnTileClick(int x, int y)
    {
        if (Controller == null || !Controller.IsIdle) return;

        if (SelectedX == -1)
        {
            SelectedX = x;
            SelectedY = y;
            StatusMessage = "Select destination";
        }
        else
        {
            if (SelectedX == x && SelectedY == y)
            {
                SelectedX = -1;
                SelectedY = -1;
                StatusMessage = "Selection Cleared";
                return;
            }

            var p1 = new Position(SelectedX, SelectedY);
            var p2 = new Position(x, y);
            
            bool allowed = Controller.TrySwap(p1, p2);
            if (!allowed)
            {
                 StatusMessage = "Invalid Move";
                 // Simple feedback, maybe shake later
                 SelectedX = -1;
                 SelectedY = -1;
            }
            else
            {
                // Selection clears on successful swap start
                SelectedX = -1;
                SelectedY = -1;
                StatusMessage = "Swapping...";
            }
        }
    }

    private string GetTileContent(Tile t) 
    {
        if (t.Type == TileType.Rainbow) return "ðŸŒˆ";
        
        string icon = t.Type switch
        {
            TileType.Red => "ðŸ”´",
            TileType.Green => "ðŸŸ¢",
            TileType.Blue => "ðŸ”µ",
            TileType.Yellow => "ðŸŸ¡",
            TileType.Purple => "ðŸŸ£",
            TileType.Orange => "ðŸŸ ",
            _ => ""
        };

        if (t.Bomb != BombType.None)
        {
            // Overlay bomb icon or replace
            return t.Bomb switch
            {
                BombType.Horizontal => icon + "â†”ï¸",
                BombType.Vertical => icon + "â†•ï¸",
                BombType.SmallCross => icon + "âž•",
                BombType.Square9x9 => icon + "ðŸ’£",
                BombType.Color => "ðŸŒˆ",
                _ => icon
            };
        }
        return icon;
    }
    
    
    class BlazorGameView : IGameView
    {
        private readonly Home _parent;
        public BlazorGameView(Home parent) => _parent = parent;
        
        // These are now just events for SFX or text status
        public void RenderBoard(TileType[,] board) { /* Deprecated/Unused */ }
        
        public void ShowSwap(Position a, Position b, bool success)
        {
             if (!success) _parent.StatusMessage = "Swap Failed!";
        }
        
        public void ShowMatches(IReadOnlyCollection<Position> matched)
        {
             _parent.LastMatchesCount = matched.Count;
             _parent.StatusMessage = $"Boom! {matched.Count} matches!";
        }
        
        public void ShowGravity(IEnumerable<TileMove> moves) { }
        public void ShowRefill(IEnumerable<TileMove> moves) { }
    }
}
