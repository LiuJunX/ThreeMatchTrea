@page "/"
@using Match3.Core
@using Match3.Core.Structs
@rendermode InteractiveServer
@implements IDisposable

<PageTitle>Match3 Game</PageTitle>

<div class="game-container">
    <div class="header">
        <h1>Match3 Blast</h1>
        <div class="stats">
            <div class="stat-box">
                <span class="stat-label">Matches</span>
                <span class="stat-value" data-testid="matches-count">@LastMatchesCount</span>
            </div>
            <div class="stat-box">
                <span class="stat-label">Status</span>
                <span class="stat-value status-text" data-testid="status-message">@StatusMessage</span>
            </div>
        </div>
        <div class="settings-box" style="margin-top: 1rem; text-align: center;">
             <label style="font-size: 0.8rem; color: #666; margin-right: 10px;">Drop Speed: @(DropSpeed)ms</label>
             <input type="range" @bind="DropSpeed" @bind:event="oninput" min="100" max="1000" step="50" style="vertical-align: middle;" />
        </div>
    </div>

    @if (Board != null)
    {
        <div class="board-wrapper">
            <div class="board" style="grid-template-columns: repeat(@Width, 60px);">
                @for (int y = 0; y < Height; y++)
                {
                    @for (int x = 0; x < Width; x++)
                    {
                        var px = x;
                        var py = y;
                        var tile = Board[x, y];
                        var isSelected = SelectedX == px && SelectedY == py;
                        var isMatched = MatchedPositions.Contains(new Position(px, py));
                        
                        <div class="tile @(isSelected ? "selected" : "") @(isMatched ? "matched" : "")" 
                             style="@GetTileStyle(px, py)"
                             @onclick="() => OnTileClick(px, py)" 
                             data-testid="tile-@px-@py">
                            <span class="tile-content">@GetTileIcon(tile)</span>
                        </div>
                    }
                }
            </div>
        </div>
        
        <div class="controls">
            <button @onclick="ResetGame" class="btn-reset">New Game</button>
            <div class="queue-status" style="font-size: 0.8em; color: #888; margin-top: 10px;">
                @if (IsAnimating)
                {
                    <span>Processing moves... (@QueueCount pending)</span>
                }
                else
                {
                    <span>Ready</span>
                }
            </div>
        </div>
    }
    else
    {
        <div class="loading">Loading Board...</div>
    }
</div>

<style>
    :root {
        --tile-size: 60px;
        --gap: 6px;
    }

    .game-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background-color: #f0f2f5;
        padding: 2rem;
        border-radius: 1rem;
        max-width: 800px;
        margin: 0 auto;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    .header {
        text-align: center;
        margin-bottom: 2rem;
        width: 100%;
    }

    h1 {
        color: #1a1a1a;
        margin-bottom: 1rem;
        font-weight: 800;
        text-transform: uppercase;
        letter-spacing: -0.025em;
    }

    .stats {
        display: flex;
        justify-content: center;
        gap: 2rem;
    }

    .stat-box {
        background: white;
        padding: 0.75rem 1.5rem;
        border-radius: 0.5rem;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        display: flex;
        flex-direction: column;
        align-items: center;
        min-width: 120px;
    }

    .stat-label {
        font-size: 0.75rem;
        color: #6b7280;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        font-weight: 600;
    }

    .stat-value {
        font-size: 1.25rem;
        font-weight: 700;
        color: #111827;
    }

    .status-text {
        font-size: 1rem;
        color: #3b82f6;
    }

    .board-wrapper {
        background: #bbada0;
        padding: 10px;
        border-radius: 6px;
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    }

    .board {
        display: grid;
        gap: var(--gap);
        background-color: #bbada0;
    }

    .tile {
        width: var(--tile-size);
        height: var(--tile-size);
        background-color: rgba(238, 228, 218, 0.35);
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        user-select: none;
        transition: transform 0.1s ease-in-out, background-color 0.2s;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .tile:hover {
        transform: scale(1.05);
        filter: brightness(1.1);
    }

    .tile.selected {
        box-shadow: 0 0 0 3px #3b82f6, 0 4px 6px rgba(0,0,0,0.2);
        z-index: 10;
        transform: scale(1.1);
    }

    .tile.matched {
        animation: pop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        opacity: 0.5;
        transform: scale(0.8);
    }

    .tile-content {
        font-size: 2rem;
        line-height: 1;
        filter: drop-shadow(0 2px 2px rgba(0,0,0,0.2));
    }

    .controls {
        margin-top: 2rem;
        text-align: center;
    }

    .btn-reset {
        background-color: #8f7a66;
        color: white;
        border: none;
        padding: 0.75rem 2rem;
        font-size: 1rem;
        font-weight: 600;
        border-radius: 0.375rem;
        cursor: pointer;
        transition: background-color 0.2s;
    }

    .btn-reset:hover {
        background-color: #9f8a76;
    }

    @@keyframes pop {
        0% { transform: scale(1); }
        50% { transform: scale(1.2); }
        100% { transform: scale(0); }
    }
</style>

@code {
    private Match3Controller? Controller;
    private TileType[,]? Board;
    private int Width = 8;
    private int Height = 8;
    private int SelectedX = -1;
    private int SelectedY = -1;
    private int LastMatchesCount = 0;
    private string StatusMessage = "Ready";
    private HashSet<Position> MatchedPositions = new();

    // Animation Controls
    private int DropSpeed = 50;
    private Dictionary<Position, int> _fallingOffsets = new();
    private List<TileMove>? _currentMoves;
    private bool _isGravityUpdate = false;
    private bool _isRefillUpdate = false;
    private bool _isAnimatingFall = false;

    // Animation Queue
    private Queue<Func<Task>> _animationQueue = new();
    private bool _isProcessingQueue = false;
    private bool _disposed = false;
    
    private bool IsAnimating => _isProcessingQueue;
    private int QueueCount => _animationQueue.Count;

    protected override void OnInitialized()
    {
        StartNewGame();
    }

    public void Dispose()
    {
        _disposed = true;
    }

    private void StartNewGame()
    {
        _animationQueue.Clear();
        MatchedPositions.Clear();
        var rng = new DefaultRandom(Environment.TickCount);
        var view = new BlazorGameView(this);
        // Controller constructor calls RenderBoard, so we capture the initial state
        Controller = new Match3Controller(Width, Height, 6, rng, view);
        StatusMessage = "Ready";
        LastMatchesCount = 0;
        SelectedX = -1;
        SelectedY = -1;
        
        // Ensure queue starts processing if not already
        _ = ProcessQueueAsync();
    }

    private void ResetGame()
    {
        StartNewGame();
    }
    
    private async Task ProcessQueueAsync()
    {
        if (_isProcessingQueue) return;
        _isProcessingQueue = true;
        StateHasChanged();

        while (!_disposed)
        {
            Func<Task>? action = null;
            lock (_animationQueue)
            {
                if (_animationQueue.Count > 0)
                {
                    action = _animationQueue.Dequeue();
                }
            }

            if (action != null)
            {
                await action();
                await Task.Delay(300); // Delay between steps for visual clarity
                StateHasChanged();
            }
            else
            {
                await Task.Delay(50); // Idle check
                if (_animationQueue.Count == 0 && _isProcessingQueue)
                {
                    // If queue is empty, update UI to show not processing, but keep loop running or exit?
                    // Better to just keep checking or use a signal, but simple polling is fine for now.
                     await InvokeAsync(StateHasChanged);
                }
            }
        }
        _isProcessingQueue = false;
    }

    private void EnqueueAction(Func<Task> action)
    {
        lock (_animationQueue)
        {
            _animationQueue.Enqueue(action);
        }
    }

    public void UpdateBoard(TileType[,] board)
    {
        var boardCopy = (TileType[,])board.Clone();
        EnqueueAction(async () => 
        {
            if (_isGravityUpdate || _isRefillUpdate)
            {
                PopulateOffsetsFromMoves();
                
                // 1. Render at new logical positions but visually offset (transition: none)
                Board = boardCopy;
                MatchedPositions.Clear();
                _isAnimatingFall = true; // Signals GetTileStyle to use 'none' transition
                await InvokeAsync(StateHasChanged);
                
                // 2. Short delay to allow DOM to reflow with the offset
                await Task.Delay(50);
                
                // 3. Clear offsets to trigger slide (enable transition)
                _fallingOffsets.Clear();
                await InvokeAsync(StateHasChanged);
                
                // 4. Wait for animation to complete
                await Task.Delay(DropSpeed);
                
                _isAnimatingFall = false;
                _isGravityUpdate = false;
                _isRefillUpdate = false;
                _currentMoves = null;
            }
            else
            {
                Board = boardCopy;
                MatchedPositions.Clear(); // Clear matches on new board render
                await InvokeAsync(StateHasChanged);
            }
        });
    }

    private void PopulateOffsetsFromMoves()
    {
        _fallingOffsets.Clear();
        if (_currentMoves == null) return;

        foreach (var move in _currentMoves)
        {
            // Calculate offset: To.Y - From.Y
            // For gravity: 5 - 2 = 3. TranslateY(-300%)
            // For refill: 2 - (-1) = 3. TranslateY(-300%)
            var offset = move.To.Y - move.From.Y;
            if (offset != 0)
            {
                _fallingOffsets[move.To] = offset;
            }
        }
    }

    private string GetTileStyle(int x, int y)
    {
        if (_fallingOffsets.TryGetValue(new Position(x, y), out int offset))
        {
            // Initial state: offset upwards, no transition
            return $"transform: translateY(-{offset * 100}%); transition: none;";
        }
        
        // If we are in the middle of an animation but this specific tile has no offset (didn't move),
        // we still want standard behavior.
        // But if we cleared offsets (second step), we want transition enabled.
        if (_isAnimatingFall && _fallingOffsets.Count == 0)
        {
            // This is the 'slide down' phase
             return $"transition: transform {DropSpeed}ms ease-in;";
        }

        return "";
    }

    public void OnSwapResult(bool success)
    {
        EnqueueAction(async () =>
        {
            StatusMessage = success ? "Swap Successful!" : "Swap Failed";
            SelectedX = -1;
            SelectedY = -1;
            await InvokeAsync(StateHasChanged);
        });
    }
    
    public void OnMatches(IReadOnlyCollection<Position> matched)
    {
        var matchedCopy = new HashSet<Position>(matched);
        EnqueueAction(async () =>
        {
            MatchedPositions = matchedCopy;
            LastMatchesCount = matchedCopy.Count;
            StatusMessage = $"Boom! {LastMatchesCount} matches!";
            await InvokeAsync(StateHasChanged);
            // Extra delay for match animation
            await Task.Delay(200); 
        });
    }

    public void OnGravity(IEnumerable<TileMove> moves)
    {
        var movesList = moves.ToList();
        EnqueueAction(async () =>
        {
            StatusMessage = "Gravity...";
            _isGravityUpdate = true;
            _currentMoves = movesList;
            await InvokeAsync(StateHasChanged);
        });
    }

    public void OnRefill(IEnumerable<TileMove> moves)
    {
         var movesList = moves.ToList();
         EnqueueAction(async () =>
        {
            StatusMessage = "Refilling...";
            _isRefillUpdate = true;
            _currentMoves = movesList;
            await InvokeAsync(StateHasChanged);
        });
    }

    private void OnTileClick(int x, int y)
    {
        // Don't allow interaction while animating
        if (QueueCount > 0) return;

        if (SelectedX == -1)
        {
            SelectedX = x;
            SelectedY = y;
            StatusMessage = "Select destination";
        }
        else
        {
            if (SelectedX == x && SelectedY == y)
            {
                SelectedX = -1;
                SelectedY = -1;
                StatusMessage = "Selection Cleared";
                return;
            }

            var p1 = new Position(SelectedX, SelectedY);
            var p2 = new Position(x, y);
            
            // This will queue up all the resulting actions
            Controller?.TrySwap(p1, p2);
        }
    }

    private string GetTileIcon(TileType t) => t switch
    {
        TileType.Red => "ðŸ”´",
        TileType.Green => "ðŸŸ¢",
        TileType.Blue => "ðŸ”µ",
        TileType.Yellow => "ðŸŸ¡",
        TileType.Purple => "ðŸŸ£",
        TileType.Orange => "ðŸŸ ",
        _ => ""
    };
    
    class BlazorGameView : IGameView
    {
        private readonly Home _parent;
        public BlazorGameView(Home parent) => _parent = parent;
        
        public void RenderBoard(TileType[,] board) => _parent.UpdateBoard(board);
        public void ShowSwap(Position a, Position b, bool success) => _parent.OnSwapResult(success);
        public void ShowMatches(IReadOnlyCollection<Position> matched) => _parent.OnMatches(matched);
        public void ShowGravity(IEnumerable<TileMove> moves) => _parent.OnGravity(moves);
        public void ShowRefill(IEnumerable<TileMove> moves) => _parent.OnRefill(moves);
    }
}
