@page "/"
@using Match3.Core
@using Match3.Core.Structs
@using System.Numerics
@rendermode InteractiveServer
@implements IDisposable

<PageTitle>Match3 Game</PageTitle>

<div class="game-container" @onpointerup="HandlePointerUp">
    <div class="header">
        <h1>Match3 Blast</h1>
        <div class="stats">
            <div class="stat-box">
                <span class="stat-label">Matches</span>
                <span class="stat-value" data-testid="matches-count">@LastMatchesCount</span>
            </div>
            <div class="stat-box">
                <span class="stat-label">Status</span>
                <span class="stat-value status-text" data-testid="status-message">@Controller.StatusMessage</span>
            </div>
        </div>
    </div>

    @if (Controller != null)
    {
        <div class="board-wrapper">
            <div class="board-container" 
                 style="width: @(Width * CellSize)px; height: @(Height * CellSize)px;"
                 @onpointerup="HandlePointerUp">
                <!-- Background Grid -->
                @for (int y = 0; y < Height; y++)
                {
                    @for (int x = 0; x < Width; x++)
                    {
                        var px = x;
                        var py = y;
                        <div class="cell-bg" 
                             style="left: @(x * CellSize)px; top: @(y * CellSize)px;"
                             @onpointerdown="e => HandlePointerDown(e, px, py)">
                        </div>
                    }
                }

                <!-- Active Tiles -->
                @foreach (var tile in Controller.State.Grid)
                {
                    if (tile.Type != TileType.None)
                    {
                        var isSelected = Controller.SelectedPosition.IsValid && 
                                       Math.Abs(tile.Position.X - Controller.SelectedPosition.X) < 0.1f && 
                                       Math.Abs(tile.Position.Y - Controller.SelectedPosition.Y) < 0.1f;
                        
                        <div class="tile @(isSelected ? "selected" : "")" 
                             style="transform: translate(@(tile.Position.X * CellSize)px, @(tile.Position.Y * CellSize)px);"
                             @onpointerdown="e => HandlePointerDown(e, (int)Math.Round(tile.Position.X), (int)Math.Round(tile.Position.Y))">
                             <div class="tile-inner">
                                <span class="tile-base">@GetTileBaseIcon(tile)</span>
                                @if (HasBombOverlay(tile))
                                {
                                    <span class="tile-overlay">@GetBombOverlayIcon(tile)</span>
                                }
                             </div>
                        </div>
                    }
                }
            </div>
        </div>
        
        <div class="controls">
            <button @onclick="ResetGame" class="btn-reset">New Game</button>
            <button @onclick="ToggleAutoPlay" class="btn-reset" style="margin-left: 10px; background-color: #3b82f6;">
                @(_isAutoPlaying ? "Stop Auto" : "Auto Play")
            </button>
            <div style="margin-top: 15px; display: flex; flex-direction: column; align-items: center; gap: 5px;">
                <label for="speedSlider" style="font-weight: 600; color: #4b5563;">Game Speed: @GameSpeed.ToString("0.0")x</label>
                <input id="speedSlider" type="range" min="0.1" max="5.0" step="0.1" @bind="GameSpeed" @bind:event="oninput" style="width: 200px; cursor: pointer;" />
            </div>
        </div>
    }
    else
    {
        <div class="loading">Loading Board...</div>
    }
</div>

<style>
    :root {
        --tile-size: 60px;
        --gap: 6px;
    }

    .game-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background-color: #f0f2f5;
        padding: 2rem;
        border-radius: 1rem;
        max-width: 800px;
        margin: 0 auto;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    .header {
        text-align: center;
        margin-bottom: 2rem;
        width: 100%;
    }

    h1 {
        color: #1a1a1a;
        margin-bottom: 1rem;
        font-weight: 800;
        text-transform: uppercase;
        letter-spacing: -0.025em;
    }

    .stats {
        display: flex;
        justify-content: center;
        gap: 2rem;
    }

    .stat-box {
        background: white;
        padding: 0.75rem 1.5rem;
        border-radius: 0.5rem;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        display: flex;
        flex-direction: column;
        align-items: center;
        min-width: 120px;
    }

    .stat-label {
        font-size: 0.75rem;
        color: #6b7280;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        font-weight: 600;
    }

    .stat-value {
        font-size: 1.25rem;
        font-weight: 700;
        color: #111827;
    }

    .status-text {
        font-size: 1rem;
        color: #3b82f6;
    }

    .board-wrapper {
        background: #bbada0;
        padding: 10px;
        border-radius: 6px;
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    }

    .board-container {
        position: relative;
        background-color: #bbada0;
    }

    .cell-bg {
        position: absolute;
        width: 60px;
        height: 60px;
        background-color: rgba(238, 228, 218, 0.35);
        border-radius: 4px;
        margin: 3px; /* Half gap */
        touch-action: none;
    }

    .tile {
        position: absolute;
        width: 60px;
        height: 60px;
        background-color: #eee4da; /* Default tile color */
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        user-select: none;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        margin: 3px; /* Half gap */
        /* IMPORTANT: No transition here, fully controlled by Model */
        z-index: 10;
        touch-action: none; /* Prevent browser scrolling/zooming/native drag */
    }

    .tile.selected {
        box-shadow: 0 0 0 3px #3b82f6, 0 4px 6px rgba(0,0,0,0.2);
        z-index: 20;
        filter: brightness(1.1);
    }

    .tile-inner {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .tile-base {
        font-size: 2rem;
        line-height: 1;
        filter: drop-shadow(0 2px 2px rgba(0,0,0,0.2));
        z-index: 1;
    }

    .tile-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 1.5rem;
        z-index: 2;
        /* Make the overlay visible on top of dark colors */
        text-shadow: 
            -1px -1px 0 #fff,  
             1px -1px 0 #fff,
            -1px  1px 0 #fff,
             1px  1px 0 #fff;
    }

    .tile-content {
        font-size: 2rem;
        line-height: 1;
        filter: drop-shadow(0 2px 2px rgba(0,0,0,0.2));
    }

    .controls {
        margin-top: 2rem;
        text-align: center;
    }

    .btn-reset {
        background-color: #8f7a66;
        color: white;
        border: none;
        padding: 0.75rem 2rem;
        font-size: 1rem;
        font-weight: 600;
        border-radius: 0.375rem;
        cursor: pointer;
        transition: background-color 0.2s;
    }

    .btn-reset:hover {
        background-color: #9f8a76;
    }
</style>

@code {
    private Match3Controller? Controller;
    private int Width = 8;
    private int Height = 8;
    private const int CellSize = 66; // 60px + 6px gap
    
    private int LastMatchesCount = 0;
    // StatusMessage delegated to Controller
    
    private bool _disposed = false;
    private bool _isAutoPlaying = false;
    private float GameSpeed = 1.0f;
    private const int TargetFps = 60;
    private const int FrameMs = 1000 / TargetFps;

    // Drag & Drop State
    private double? _dragStartX;
    private double? _dragStartY;
    private int _dragSourceX = -1;
    private int _dragSourceY = -1;
    private const double DragThreshold = 20.0; // pixels

    protected override void OnInitialized()
    {
        StartNewGame();
    }

    public void Dispose()
    {
        _disposed = true;
    }

    private void StartNewGame()
    {
        _isAutoPlaying = false;
        var rng = new DefaultRandom(Environment.TickCount);
        var view = new BlazorGameView(this);
        Controller = new Match3Controller(Width, Height, 6, rng, view);
        LastMatchesCount = 0;
        
        // Start Game Loop
        _ = GameLoopAsync();
    }

    private void ResetGame()
    {
        StartNewGame();
    }
    
    private void ToggleAutoPlay()
    {
        _isAutoPlaying = !_isAutoPlaying;
    }

    private async Task GameLoopAsync()
    {
        while (!_disposed)
        {
            if (Controller != null)
            {
                // Update Logic
                Controller.Update((FrameMs / 1000.0f) * GameSpeed);
                
                // Auto Play Logic
                if (_isAutoPlaying && Controller.IsIdle)
                {
                    bool moved = Controller.TryMakeRandomMove();
                    // If no move found, we might want to wait or stop, but for now just loop
                }

                // Update UI
                await InvokeAsync(StateHasChanged);
            }
            
            await Task.Delay(FrameMs);
        }
    }

    private void HandlePointerDown(PointerEventArgs e, int x, int y)
    {
        if (Controller == null || !Controller.IsIdle) return;
        
        _dragStartX = e.ClientX;
        _dragStartY = e.ClientY;
        _dragSourceX = x;
        _dragSourceY = y;
    }

    private void HandlePointerUp(PointerEventArgs e)
    {
        if (_dragStartX == null || _dragStartY == null || _dragSourceX == -1) return;

        var deltaX = e.ClientX - _dragStartX.Value;
        var deltaY = e.ClientY - _dragStartY.Value;
        var distance = Math.Sqrt(deltaX * deltaX + deltaY * deltaY);

        if (distance < DragThreshold)
        {
            // Treat as Click
            OnTileClick(_dragSourceX, _dragSourceY);
        }
        else
        {
            // Treat as Swipe
            HandleSwipe(deltaX, deltaY);
        }

        // Reset
        _dragStartX = null;
        _dragStartY = null;
        _dragSourceX = -1;
        _dragSourceY = -1;
    }

    private void HandleSwipe(double dx, double dy)
    {
        if (Controller == null) return;

        // Determine main direction
        Direction direction;
        if (Math.Abs(dx) > Math.Abs(dy))
        {
            // Horizontal
            direction = dx > 0 ? Direction.Right : Direction.Left;
        }
        else
        {
            // Vertical
            direction = dy > 0 ? Direction.Down : Direction.Up;
        }

        var p1 = new Position(_dragSourceX, _dragSourceY);
        Controller.OnSwipe(p1, direction);
    }

    private void OnTileClick(int x, int y)
    {
        if (Controller == null) return;
        Controller.OnTap(new Position(x, y));
    }

    private string GetTileBaseIcon(Tile t) 
    {
        if (t.Type == TileType.Rainbow) return "ðŸŒˆ";
        
        return t.Type switch
        {
            TileType.Red => "ðŸ”´",
            TileType.Green => "ðŸŸ¢",
            TileType.Blue => "ðŸ”µ",
            TileType.Yellow => "ðŸŸ¡",
            TileType.Purple => "ðŸŸ£",
            TileType.Orange => "ðŸŸ ",
            _ => ""
        };
    }

    private bool HasBombOverlay(Tile t)
    {
        // Rainbow tile doesn't need overlay usually, or maybe it does if it's special?
        // Logic: Only normal colors with bomb types get overlay. 
        // Or if it is a Color bomb (Rainbow), it is just Rainbow.
        if (t.Type == TileType.Rainbow) return false; 
        return t.Bomb != BombType.None && t.Bomb != BombType.Color;
    }

    private string GetBombOverlayIcon(Tile t)
    {
        return t.Bomb switch
        {
            BombType.Horizontal => "â†”ï¸",
            BombType.Vertical => "â†•ï¸",
            BombType.SmallCross => "âž•",
            BombType.Square9x9 => "ðŸ’£",
            // BombType.Color is handled by BaseIcon being Rainbow
            _ => ""
        };
    }
    
    // Deprecated but keeping for reference or if used elsewhere
    private string GetTileContent(Tile t) 
    {
        if (t.Type == TileType.Rainbow) return "ðŸŒˆ";
        // ... (Old Logic)
        return GetTileBaseIcon(t); 
    }
    
    
    class BlazorGameView : IGameView
    {
        private readonly Home _parent;
        public BlazorGameView(Home parent) => _parent = parent;
        
        // These are now just events for SFX or text status
        public void RenderBoard(TileType[,] board) { /* Deprecated/Unused */ }
        
        public void ShowSwap(Position a, Position b, bool success)
        {
             // Status managed by Controller
        }
        
        public void ShowMatches(IReadOnlyCollection<Position> matched)
        {
             _parent.LastMatchesCount = matched.Count;
             // Status managed by Controller
        }
        
        public void ShowGravity(IEnumerable<TileMove> moves) { }
        public void ShowRefill(IEnumerable<TileMove> moves) { }
    }
}
