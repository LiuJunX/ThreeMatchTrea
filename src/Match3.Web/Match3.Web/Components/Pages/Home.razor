@page "/"
@using Match3.Core
@using Match3.Core.Structs
@using System.Numerics
@using Match3.Web.Services
@inject Match3GameService GameService
@rendermode InteractiveServer
@implements IDisposable

<PageTitle>Match3 Game</PageTitle>

<div class="game-container" @onpointerup="HandlePointerUp">
    <div class="header">
        <h1>Match3 Blast</h1>
        <div class="stats">
            <div class="stat-box">
                <span class="stat-label">Matches</span>
                <span class="stat-value" data-testid="matches-count">@GameService.LastMatchesCount</span>
            </div>
            <div class="stat-box">
                <span class="stat-label">Status</span>
                <span class="stat-value status-text" data-testid="status-message">@(GameService.Controller?.StatusMessage ?? "Loading...")</span>
            </div>
        </div>
    </div>

    @if (GameService.Controller != null)
    {
        <div class="board-wrapper">
            <div class="board-container" 
                 style="width: @(GameService.Width * Match3GameService.CellSize)px; height: @(GameService.Height * Match3GameService.CellSize)px;"
                 @onpointerup="HandlePointerUp">
                <!-- Background Grid -->
                @for (int y = 0; y < GameService.Height; y++)
                {
                    @for (int x = 0; x < GameService.Width; x++)
                    {
                        var px = x;
                        var py = y;
                        <div class="cell-bg" 
                             style="left: @(x * Match3GameService.CellSize)px; top: @(y * Match3GameService.CellSize)px;"
                             @onpointerdown="e => HandlePointerDown(e, px, py)">
                        </div>
                    }
                }

                <!-- Active Tiles -->
                @foreach (var tile in GameService.Controller.State.Grid)
                {
                    if (tile.Type != TileType.None)
                    {
                        var isSelected = GameService.Controller.SelectedPosition.IsValid && 
                                       Math.Abs(tile.Position.X - GameService.Controller.SelectedPosition.X) < 0.1f && 
                                       Math.Abs(tile.Position.Y - GameService.Controller.SelectedPosition.Y) < 0.1f;
                        
                        <div @key="tile.Id" class="tile @(isSelected ? "selected" : "")" 
                             style="transform: translate(@(tile.Position.X * Match3GameService.CellSize)px, @(tile.Position.Y * Match3GameService.CellSize)px);"
                             @onpointerdown="e => HandlePointerDown(e, (int)Math.Round(tile.Position.X), (int)Math.Round(tile.Position.Y))">
                             <div class="tile-inner">
                                <span class="tile-base">@GetTileBaseIcon(tile)</span>
                                @if (HasBombOverlay(tile))
                                {
                                    <span class="tile-overlay">@GetBombOverlayIcon(tile)</span>
                                }
                             </div>
                        </div>
                    }
                }
            </div>
        </div>
        
        <div class="controls">
            <button @onclick="ResetGame" class="btn-reset">New Game</button>
            <button @onclick="ToggleAutoPlay" class="btn-reset" style="margin-left: 10px; background-color: #3b82f6;">
                @(GameService.IsAutoPlaying ? "Stop Auto" : "Auto Play")
            </button>
            <div style="margin-top: 15px; display: flex; flex-direction: column; align-items: center; gap: 5px;">
                <label for="speedSlider" style="font-weight: 600; color: #4b5563;">Game Speed: @GameService.GameSpeed.ToString("0.0")x</label>
                <input id="speedSlider" type="range" min="0.1" max="5.0" step="0.1" @bind="GameService.GameSpeed" @bind:event="oninput" style="width: 200px; cursor: pointer;" />
            </div>
        </div>
    }
    else
    {
        <div class="loading">Loading Board...</div>
    }
</div>

<style>
    :root {
        --tile-size: 60px;
        --gap: 6px;
    }

    .game-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background-color: #f0f2f5;
        padding: 2rem;
        border-radius: 1rem;
        max-width: 800px;
        margin: 0 auto;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    .header {
        text-align: center;
        margin-bottom: 2rem;
        width: 100%;
    }

    h1 {
        color: #1a1a1a;
        margin-bottom: 1rem;
        font-weight: 800;
        text-transform: uppercase;
        letter-spacing: -0.025em;
    }

    .stats {
        display: flex;
        justify-content: center;
        gap: 2rem;
    }

    .stat-box {
        background: white;
        padding: 0.75rem 1.5rem;
        border-radius: 0.5rem;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        display: flex;
        flex-direction: column;
        align-items: center;
        min-width: 120px;
    }

    .stat-label {
        font-size: 0.75rem;
        color: #6b7280;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        font-weight: 600;
    }

    .stat-value {
        font-size: 1.25rem;
        font-weight: 700;
        color: #111827;
    }

    .status-text {
        font-size: 1rem;
        color: #3b82f6;
    }

    .board-wrapper {
        background: #bbada0;
        padding: 10px;
        border-radius: 6px;
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    }

    .board-container {
        position: relative;
        background-color: #bbada0;
    }

    .cell-bg {
        position: absolute;
        width: 60px;
        height: 60px;
        background-color: rgba(238, 228, 218, 0.35);
        border-radius: 4px;
        margin: 3px; /* Half gap */
        touch-action: none;
    }

    .tile {
        position: absolute;
        width: 60px;
        height: 60px;
        background-color: #eee4da; /* Default tile color */
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        user-select: none;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        margin: 3px; /* Half gap */
        /* IMPORTANT: No transition here, fully controlled by Model */
        z-index: 10;
        touch-action: none; /* Prevent browser scrolling/zooming/native drag */
    }

    .tile.selected {
        box-shadow: 0 0 0 3px #3b82f6, 0 4px 6px rgba(0,0,0,0.2);
        z-index: 20;
        filter: brightness(1.1);
    }

    .tile-inner {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .tile-base {
        font-size: 2rem;
        line-height: 1;
        filter: drop-shadow(0 2px 2px rgba(0,0,0,0.2));
        z-index: 1;
    }

    .tile-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 1.5rem;
        z-index: 2;
        /* Make the overlay visible on top of dark colors */
        text-shadow: 
            -1px -1px 0 #fff,  
             1px -1px 0 #fff,
            -1px  1px 0 #fff,
             1px  1px 0 #fff;
    }

    .tile-content {
        font-size: 2rem;
        line-height: 1;
        filter: drop-shadow(0 2px 2px rgba(0,0,0,0.2));
    }

    .controls {
        margin-top: 2rem;
        text-align: center;
    }

    .btn-reset {
        background-color: #8f7a66;
        color: white;
        border: none;
        padding: 0.75rem 2rem;
        font-size: 1rem;
        font-weight: 600;
        border-radius: 0.375rem;
        cursor: pointer;
        transition: background-color 0.2s;
    }

    .btn-reset:hover {
        background-color: #9f8a76;
    }
</style>

@code {
    // Drag & Drop State
    private double? _dragStartX;
    private double? _dragStartY;
    private int _dragSourceX = -1;
    private int _dragSourceY = -1;
    private const double DragThreshold = 20.0; // pixels

    protected override void OnInitialized()
    {
        GameService.OnChange += OnGameStateChanged;
        
        // Start game if not already started (Singleton/Scoped behavior)
        if (GameService.Controller == null)
        {
            GameService.StartNewGame();
        }
    }

    public void Dispose()
    {
        GameService.OnChange -= OnGameStateChanged;
    }

    private void OnGameStateChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    private void ResetGame()
    {
        GameService.ResetGame();
    }
    
    private void ToggleAutoPlay()
    {
        GameService.ToggleAutoPlay();
    }

    private void HandlePointerDown(PointerEventArgs e, int x, int y)
    {
        if (GameService.Controller == null || !GameService.Controller.IsIdle) return;
        
        _dragStartX = e.ClientX;
        _dragStartY = e.ClientY;
        _dragSourceX = x;
        _dragSourceY = y;
    }

    private void HandlePointerUp(PointerEventArgs e)
    {
        if (_dragStartX == null || _dragStartY == null || _dragSourceX == -1) return;

        var deltaX = e.ClientX - _dragStartX.Value;
        var deltaY = e.ClientY - _dragStartY.Value;
        var distance = Math.Sqrt(deltaX * deltaX + deltaY * deltaY);

        if (distance < DragThreshold)
        {
            // Treat as Click
            OnTileClick(_dragSourceX, _dragSourceY);
        }
        else
        {
            // Treat as Swipe
            HandleSwipe(deltaX, deltaY);
        }

        // Reset
        _dragStartX = null;
        _dragStartY = null;
        _dragSourceX = -1;
        _dragSourceY = -1;
    }

    private void HandleSwipe(double dx, double dy)
    {
        if (GameService.Controller == null) return;

        // Determine main direction
        Direction direction;
        if (Math.Abs(dx) > Math.Abs(dy))
        {
            // Horizontal
            direction = dx > 0 ? Direction.Right : Direction.Left;
        }
        else
        {
            // Vertical
            direction = dy > 0 ? Direction.Down : Direction.Up;
        }

        var p1 = new Position(_dragSourceX, _dragSourceY);
        GameService.OnSwipe(p1, direction);
    }

    private void OnTileClick(int x, int y)
    {
        GameService.OnTap(x, y);
    }

    private string GetTileBaseIcon(Tile t) 
    {
        if (t.Type == TileType.Rainbow) return "ðŸŒˆ";
        
        return t.Type switch
        {
            TileType.Red => "ðŸ”´",
            TileType.Green => "ðŸŸ¢",
            TileType.Blue => "ðŸ”µ",
            TileType.Yellow => "ðŸŸ¡",
            TileType.Purple => "ðŸŸ£",
            TileType.Orange => "ðŸŸ ",
            _ => ""
        };
    }

    private bool HasBombOverlay(Tile t)
    {
        if (t.Type == TileType.Rainbow) return false; 
        return t.Bomb != BombType.None && t.Bomb != BombType.Color;
    }

    private string GetBombOverlayIcon(Tile t)
    {
        return t.Bomb switch
        {
            BombType.Horizontal => "â†”ï¸",
            BombType.Vertical => "â†•ï¸",
            BombType.SmallCross => "âž•",
            BombType.Square9x9 => "ðŸ’£",
            _ => ""
        };
    }
}
