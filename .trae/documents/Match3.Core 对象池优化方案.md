# 优化对象池性能与易用性 (修订版)

针对您关心的“是否必须传入容量”的问题，我的方案是：**不需要**。

默认调用 `Pools.ObtainList()` 会自动返回一个“小容量”的标准列表，**彻底避免**拿到大列表造成的内存浪费。只有当您明确知道需要处理大量数据时，才需要传入容量参数以获得额外的性能提升。

## 核心设计：智能分级池 (Bucketed List Pool)

我们将 `List<T>` 的池化逻辑升级为“双轨制”：

1.  **标准池 (Standard Pool)**:
    - 存放容量 **< 128** 的列表。
    - **默认行为**: `Pools.ObtainList()` 总是从这里取对象。
    - **优势**: 保证普通用户永远不会意外拿到占用大量内存的“巨型列表”。

2.  **大对象池 (Large Pool)**:
    - 存放容量 **128 ~ 2048** 的列表。
    - **触发条件**: 只有显式调用 `Pools.ObtainList(1000)` 时尝试从这里取。
    - **优势**: 为重度负载（如寻路、全图扫描）提供复用，避免重新分配。

3.  **熔断机制**:
    - 容量 **> 2048** 的列表在归还时会被**直接丢弃**，不再放回池中，防止内存泄漏式的无限增长。

## 易用性升级

除了性能，我们还将大幅简化 API 使用：

### 1. 传统方式 (向下兼容)
```csharp
var list = Pools.ObtainList<int>(); // 默认返回小列表，无需参数
// ... 使用 ...
Pools.Release(list); // 自动归类到标准池或大对象池
```

### 2. 新增：Disposable 模式 (推荐)
利用 `using` 语法自动归还，再也不用担心忘记 Release。
```csharp
using var handle = Pools.ObtainDisposableList<int>(out var list);
list.Add(1);
// 作用域结束时自动归还
```

## 实施计划

1.  **创建 `BucketedListPool<T>`**: 实现上述分级与熔断逻辑。
2.  **改造 `Pools.cs`**:
    - 替换旧的 `GenericObjectPool`。
    - 更新 `ObtainList` 支持可选参数。
    - 添加 `ObtainDisposableList`。
3.  **验证**: 编写测试用例确保“不传参拿到的是小列表”、“传大参拿到的是大列表”。
