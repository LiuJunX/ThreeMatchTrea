# 编辑器驱动的测试开发流程 (Editor-Driven TDD)

针对您的需求，我设计了如下闭环工作流，将编辑器、测试用例与核心逻辑开发紧密结合：

## 1. 流程设计

### 第一步：定义 (Define & Reproduce)
利用编辑器作为**可视化测试生成器**。
*   **创建场景**：在编辑器中设置初始盘面（如 `Level1.json` 的布局）。
*   **录制操作**：在 "Scenario / Test" 模式下，开启录制 (Recording)，执行操作（如交换 (1,0) 和 (1,1)）。
*   **定义断言**：在操作后的结果盘面上，右键点击格子添加断言 (Assertion)，例如“此处必须是垂直炸弹”。
*   **保存用例**：保存为 JSON 文件到 `Match3.Core.Tests/Scenarios/Data`。

### 第二步：验证与调试 (Verify & Debug)
利用编辑器作为**可视化调试器**。
*   **可视化运行**：在编辑器中加载 Scenario，点击“播放”或“单步执行”。
*   **观察差异**：直接观察实际运行结果与预期的差异。
    *   *当前案例*：您会看到炸弹生成在了 (2,1) 而不是预期的 (1,1)，或者根本没生成。
*   **定位问题**：结合代码断点，定位是识别算法 (`MatchFinder`) 还是消除逻辑 (`MatchProcessor`) 的问题。

### 第三步：修复与实现 (Fix & Implement)
在核心层修改逻辑。
*   **分析原因**：`Level1.json` 失败的根本原因是 `GameLoopSystem` 在消除结算时丢失了“玩家最后操作位置”的上下文，导致系统默认选择了消除组的中心点作为炸弹生成点，而非玩家交换点。
*   **代码修正**：修改 `GameLoopSystem` 和 `MatchFinder`，支持将玩家操作坐标透传给消除逻辑。

### 第四步：回归测试 (Regression)
*   **单元测试**：运行 `dotnet test`，确保 Scenario 通过。
*   **批量验证**：CI/CD 自动运行所有 Scenario，防止逻辑修改破坏其他关卡（例如 T形消除、L形消除）。

---

## 2. 针对当前失败用例的修复计划

我将演示如何应用此流程修复 `Level1.json`：

### 问题分析
*   **现象**：4连消（水平）生成了炸弹，但生成位置默认取了中心点 `(2,1)`，而测试用例期望生成在玩家交换点 `(1,1)`。因此 (1,1) 处没有炸弹，断言失败。
*   **根源**：`ResolveMatches` 方法调用 `FindMatchGroups` 时未传入 Focus 坐标。

### 实施步骤
1.  **重构接口**：修改 `IMatchFinder.FindMatchGroups`，使其接受 `IEnumerable<Position> focusPositions`（支持多个关注点，如交换的A和B）。
2.  **更新逻辑**：在 `ClassicMatchFinder` 中，优先选择包含在 `focusPositions` 中的坐标作为 `BombOrigin`。
3.  **传递上下文**：在 `GameLoopSystem` 中，当交换发生时记录坐标，并在随后的 `ResolveMatches` 中传递给 `MatchFinder`。
4.  **验证**：运行 `dotnet test` 验证修复。
