感谢您的重要提示。为了确保架构对 Unity 等其他平台的兼容性，我将采用 **"依赖倒置 (Dependency Inversion)"** 策略，确保 `LevelEditorViewModel` 不依赖任何 Web 特定实现或直接的文件系统访问。

### 1. 核心架构调整 (Architecture Refactoring)

为了实现真正的平台无关性，我们将引入 `IScenarioService` 接口层：

*   **定义接口**: 在 `Match3.Editor/Interfaces` 中定义 `IScenarioService`。
    *   包含 `BuildTree`, `ReadScenario`, `WriteScenario`, `CreateNode`, `DeleteNode` 等抽象方法。
*   **实现接口**: 改造 `Match3.Web/Services/ScenarioLibraryService.cs` 以实现此接口。
    *   未来在 Unity 中，您可以轻松实现一个 `UnityScenarioService` (基于 `AssetDatabase`)。
*   **注入依赖**: `LevelEditorViewModel` 将只依赖 `IScenarioService` 和 `IPlatformService`，不再直接进行任何 IO 操作。

### 2. 组件化拆分 (UI Refactoring)

我们将 `LevelEditor.razor` 拆分为纯 UI 组件（位于 `src/Match3.Web/Components/Pages/EditorComponents`）：

1.  **`EditorHeader.razor`**: 纯展示，点击按钮调用 `VM.SwitchMode()` 或 `VM.StartGame()`。
2.  **`EditorConfigPanel.razor`**: 绑定 `VM.EditorWidth` 等属性；文件树操作通过 `VM.SelectFile()` 或 `VM.ExecuteContextAction()` 触发。
3.  **`EditorToolsPanel.razor`**: 绑定 `VM.SelectedType`，工具栏。
4.  **`EditorCanvas.razor`**: 负责将鼠标事件转换为网格坐标，然后调用 `VM.HandleGridClick(x, y)`。
    *   *注意*: 右键菜单的**位置(x,y)**计算仍保留在 View 层，但**点击动作**会直接转发给 VM。

### 3. 执行步骤

1.  **接口定义**: 创建 `Match3.Editor/Interfaces/IScenarioService.cs`。
2.  **服务适配**: 让 `ScenarioLibraryService` 实现该接口，并在 `Program.cs` 中注册。
3.  **ViewModel 升级**:
    *   注入 `IScenarioService`。
    *   迁移 `Load`, `Save`, `Delete`, `Create` 等逻辑到 VM。
    *   移除所有 Web 特定的类型（如 `MouseEventArgs`）。
4.  **UI 拆分**: 创建上述 4 个 Razor 组件并替换主页面内容。

此方案完全符合 "Clean Architecture" 和您的跨平台要求。是否开始执行？